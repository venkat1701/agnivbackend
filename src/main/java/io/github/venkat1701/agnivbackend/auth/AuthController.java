package io.github.venkat1701.agnivbackend.auth;

import io.github.venkat1701.agnivbackend.dto.auth.AuthResponse;
import io.github.venkat1701.agnivbackend.dto.auth.LoginDTO;
import io.github.venkat1701.agnivbackend.exceptions.UserException;
import io.github.venkat1701.agnivbackend.model.User;
import io.github.venkat1701.agnivbackend.repository.auth.UserRepository;
import io.github.venkat1701.agnivbackend.security.jwt.JwtProvider;
import io.github.venkat1701.agnivbackend.service.auth.UserService;
import jdk.jshell.spi.ExecutionControl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


/**
 * Handles authentication-related operations.
 *
 * <p>This class is the entrypoint for authentication-related operations. It is
 * responsible for validating the user credentials and generating the JWT token
 * for the user. The {@link LoginDTO} method is the main entry point for
 * the authentication process.</p>
 *
 * <p>The {@link LoginDTO} method is annotated with {@link PostMapping} and
 * accepts a {@link LoginDTO} which contains the user's email and password. The
 * method validates the user's credentials and if the credentials are valid, it
 * generates a JWT token for the user and returns a {@link ResponseEntity} with
 * HTTP status code 200 and a body of type {@link AuthResponse}.</p>
 * @author Venkat
 */
@RestController
@RequestMapping("/auth")
public class AuthController {

    private final UserService userService;
    private final UserRepository userRepository;
    private final JwtProvider jwtProvider;
    private final PasswordEncoder passwordEncoder;
    /**
     * Constructs an instance of the AuthController with the given {@link UserService}, {@link UserRepository}, {@link JwtProvider}, and {@link PasswordEncoder}.
     *
     * @param userService      the service that handles user-related operations
     * @param userRepository   the repository that stores the user data
     * @param jwtProvider       the utility that generates the JWT token
     * @param passwordEncoder   the utility that encodes the password
     */
    @Autowired
    public AuthController(UserService userService, UserRepository userRepository, JwtProvider jwtProvider, PasswordEncoder passwordEncoder) {
        this.userService = userService;
        this.userRepository = userRepository;
        this.jwtProvider = jwtProvider;
        this.passwordEncoder = passwordEncoder;
    }

    /**
     * Creates a new user.
     *
     * <p>This method is responsible for creating a new user in the system. It is
     * annotated with {@link PostMapping} and accepts a {@link User} which
     * contains the user's email and password. The email must be unique and
     * the password must be non-empty and must be between 8 and 16 characters in
     * length.</p>
     *
     * <p>The method returns a {@link ResponseEntity} with HTTP status code 201
     * and a body of type {@link AuthResponse} which contains the JWT token for
     * the user. The JWT token is generated by the {@link JwtProvider}.</p>
     * @param user the user data
     * @return a ResponseEntity that contains the JWT token
     * @throws ExecutionControl.UserException if the user with the given email exists
     * @throws UserException if the user data is invalid
     */
    @PostMapping("/signup")
    public ResponseEntity<AuthResponse> createUserHandler(@RequestBody User user) throws ExecutionControl.UserException, UserException {
        String email = user.getEmail();
        String password = user.getPassword();

        if (userRepository.findByEmail(email) != null) {
            throw new UserException("User with this email exists! Try signing in with a different email.");
        }
        User createdUser = new User();
        createdUser.setEmail(email);
        createdUser.setPassword(passwordEncoder.encode(password));
        createdUser.setFirstName(user.getFirstName());
        createdUser.setLastName(user.getLastName());
        createdUser = userRepository.save(createdUser);

        Authentication authentication = new UsernamePasswordAuthenticationToken(email, null, null);
        SecurityContextHolder.getContext().setAuthentication(authentication);

        String jwt = jwtProvider.generateToken(authentication, createdUser.getId());
        return new ResponseEntity<>(new AuthResponse(jwt, "Token Generated with User ID " + user.getId()), HttpStatus.CREATED);
    }

    /**
     * Logs in an existing user.
     *
     * <p>This method is responsible for logging in an existing user in the system. It is
     * annotated with {@link PostMapping} and accepts a {@link LoginDTO} which
     * contains the user's email and password. The email must be unique and
     * the password must be non-empty and must be between 8 and 16 characters in
     * length.</p>
     *
     * <p>The method returns a {@link ResponseEntity} with HTTP status code 200
     * and a body of type {@link AuthResponse} which contains the JWT token for
     * the user. The JWT token is generated by the {@link JwtProvider}.</p>
     *
     * <p>The method {@link #authenticate(String, String)} is used to authenticate the user
     * with the given email and password. If the user credentials are valid, the
     * method returns the {@link Authentication} object for the user. If the user
     * credentials are invalid, the method throws a {@link BadCredentialsException}.</p>
     * @param loginDTO the user data
     * @return a ResponseEntity that contains the JWT token
     * @throws BadCredentialsException if the user credentials are invalid
     */
    @PostMapping("/signin")
    public ResponseEntity<AuthResponse> loginUserHandler(@RequestBody LoginDTO loginDTO) {
        String email = loginDTO.getEmail();
        String password = loginDTO.getPassword();

        Authentication authentication = authenticate(email, password);

        User user = userRepository.findByEmail(email);
        if (user == null) {
            throw new BadCredentialsException("Invalid Email or Password.");
        }

        String jwt = jwtProvider.generateToken(authentication, user.getId());
        return new ResponseEntity<>(new AuthResponse(jwt, "Token Generated with User ID " + user.getId()), HttpStatus.OK);
    }
    /**
     * Authenticates the user with the given email and password.
     *
     * <p>This method is responsible for authenticating the user with the given email and password. It is
     * a private method and is only accessible within the class. It is
     * annotated with {@link PostMapping} and accepts a {@link LoginDTO} which
     * contains the user's email and password. The email must be unique and
     * the password must be non-empty and must be between 8 and 16 characters in
     * length.</p>
     *
     * <p>The method returns an {@link Authentication} object for the user. If the user
     * credentials are invalid, the method throws a {@link BadCredentialsException}.</p>
     * @param email the email of the user
     * @param password the password of the user
     * @return an Authentication object for the user
     * @throws BadCredentialsException if the user credentials are invalid
     */
    private Authentication authenticate(String email, String password) {
        UserDetails userDetails = userService.loadUserByUsername(email);

        if (userDetails == null) {
            throw new BadCredentialsException("Invalid Email or Password.");
        }

        if (!passwordEncoder.matches(password, userDetails.getPassword())) {
            throw new BadCredentialsException("Invalid Password.");
        }
        return new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
    }
}
